/*
 *  RandomStrategyTest.java
 *
 *  Copyright (c) 2010, 2011 Roberto Corradini. All rights reserved.
 *
 *  This file is part of the reversi program
 *  http://github.com/rcrr/reversi
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation; either version 3, or (at your option) any
 *  later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
 *  or visit the site <http://www.gnu.org/licenses/>.
 */

package rcrr.reversi;

import org.joda.time.Duration;
import org.joda.time.Period;

import java.util.Map;
import java.util.HashMap;

import java.util.Set;
import java.util.HashSet;

import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;

import org.junit.*;
import static org.junit.Assert.*;

import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.not;
import static org.hamcrest.CoreMatchers.instanceOf;

import static rcrr.reversi.Square.*;

/**
 * Test Suite for {@code RandomStrategy} class.
 * <p>
 * This test suite verifies that {@code RandomStrategy} returns
 * a statistical distribution of moves that is equally distributed
 * among the legal moves.
 * <p>
 * The <b>mean</b> of the chance to obtain a given move among <i>N</i> legal ones
 * is <i>1/N</i>.
 * <p>
 * The related <b>variance</b> is expressed by <i>(N-1)/N^2</i>.
 * <p>
 * For instance let's take a four legal move case: the mean is equal to <i>0.25</i>
 * while the variance is <i>0.1875</i>.
 * <p>
 * A sample population <i>p</i> is created running <i>k</i> times the random move strategy.
 * Let be:
 * <ul>
 *  <li><i>m</i> the mean value of the population (being <i>1/N</i>)</li>
 *  <li><i>v</i> the variance of the population (being <i>(N-1)/N^2</i>)</li>
 *  <li><i>k</i> the number of members of a sample population</li>
 *  <li><i>mk</i> the mean of the sample population composed by <i>k</i> members</li>
 *  <li><i>vk</i> the variance of the sample population composed by <i>k</i> members</li>
 * </ul>
 * <p>
 * Let now consider a population <i>q</i> of <i>j</i> members build taking the mean value
 * <i>mk</i> of <i>j</i> populations <i>p</i>, let be: 
 * <ul>
 *  <li><i>vmk</i> the variance of the population <i>q</i></li>
 * </ul>
 * <p>
 * The values of <i>v</i>, <i>vmk</i>, and <i>k</i> are binded by the following equation:
 * <ul>
 *  <li><i>vmk = v / k</i></li>
 * </ul>
 * <p>
 * The test verifies that, for a large enough <i>j</i> size, the calculated <i>vmk</i>
 * from the array of sample populations obtained calling the {@code RandomStrategy} code
 * is always less than two times the theoretical value:
 * <ul>
 *  <li><i>calculated(vmk) &lt 2 * (v / k)</i></li>
 * </ul>
 * <p>
 * The test, in other words, verifies that the
 * <a href="http://en.wikipedia.org/wiki/Central_limit_theorem" target="_blank">Central Limit Theorem</a>
 * is applicable to the sample populations generated by the {@code RandomStrategy} procedure,
 * confirming that the generation is random and normally distributed.
 */
public class RandomStrategyTest {

    /** Class constructor. */
    public RandomStrategyTest() { }

    /**
     * A statistical model is a wrapper for a game snapshot.
     * <p>
     * It is used to compute the main statistical properties for the given snapshot.
     */
    static private class StatisticalModel {

        /** The random strategy generating the sample populations. */
        private Strategy strategy = new RandomStrategy();

        private final GameSnapshot snapshot; /** The game snapshot representing the statistical environment. */
        private final Set<Square> legalMovesSpace; /** The set of all possible values. */
        private final int enne; /** The numorosity of the legal moves space. */
        private final double mean; /** The theoretical probability to receive a given value from a random selection. */
        private final double variance; /** The theoretical statistical variance of a sample population of random selection. */

        /** Class constructor. */
        StatisticalModel(final GameSnapshot snapshot) {
            this.snapshot = snapshot;
            this.legalMovesSpace = new HashSet<Square>(snapshot.board().legalMoves(snapshot.player()));
            this.enne = legalMovesSpace.size();
            this.mean = (double) 1. / (double) enne;
            this.variance = (double) (enne - 1) / (double) Math.pow((double) enne, 2.);
        }

        int enne() { return this.enne; }
        double mean() { return this.mean; }
        double variance() { return this.variance; }
        GameSnapshot snapshot() { return this.snapshot; }
        Set<Square> legalMovesSpace() { return this.legalMovesSpace; }

        /**
         * Returns a new sample related to the model.
         *
         * @param sampleSize the number of moves componing the sample
         * @return           a new sample
         */
        Sample sample(final int sampleSize) {
            List<Square> squares = new ArrayList<Square>(sampleSize);
            for (int i=0; i<sampleSize; i++) {
                Square sq = strategy.move(snapshot).square();
                assertTrue(legalMovesSpace.contains(sq));
                squares.add(sq);
            }
            return new Sample(squares, this);
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append("{legalMovesSpate=" + legalMovesSpace + ", ");
            sb.append("enne=" + enne + ", ");
            sb.append("mean=" + mean + ", ");
            sb.append("variance=" + variance + "}");
            return sb.toString();
        }

    }

    private static class SampleSet {

        private final StatisticalModel model;
        private final Set<Sample> samples;

        private final int sampleSize;
        private final int setSize;

        private final Map<Square, Double> meanOfMeans;
        private final Map<Square, Double> meanOfVariances;
        private final Map<Square, Double> varianceOfMeans;

        SampleSet(final int sampleSize, final int setSize, final StatisticalModel model) {
            this.model = model;
            this.sampleSize = sampleSize;
            this.setSize = setSize;
            this.samples = new HashSet<Sample>(setSize);
            for (int k = 0; k < setSize; k++) {
                samples.add(model.sample(sampleSize));
            }

            /** Calculates the means of the means. */
            this.meanOfMeans = new HashMap<Square, Double>(model.enne());
            for (Square sq : model.legalMovesSpace()) {
                meanOfMeans.put(sq, (double) 0.);
            }
            for (Sample sample : this.samples) {
                for (Square sq : model.legalMovesSpace()) {
                    meanOfMeans.put(sq, meanOfMeans.get(sq) + sample.means().get(sq));
                }
            }
            for (Square sq : model.legalMovesSpace()) {
                meanOfMeans.put(sq, meanOfMeans.get(sq) / (double) setSize);
            }

            /** Calculates the means of the variances. */
            this.meanOfVariances = new HashMap<Square, Double>(model.enne());
            for (Square sq : model.legalMovesSpace()) {
                meanOfVariances.put(sq, (double) 0.);
            }
            for (Sample sample : this.samples) {
                for (Square sq : model.legalMovesSpace()) {
                    meanOfVariances.put(sq, meanOfVariances.get(sq) + sample.variances().get(sq));
                }
            }
            for (Square sq : model.legalMovesSpace()) {
                meanOfVariances.put(sq, meanOfVariances.get(sq) / (double) setSize);
            }

            /** Calculates the variances of the means. */
            this.varianceOfMeans = new HashMap<Square, Double>(model.enne());
            for (Square sq : model.legalMovesSpace()) {
                varianceOfMeans.put(sq, (double) 0.);
            }
            for (Sample sample : this.samples) {
                for (Square sq : model.legalMovesSpace()) {
                    double deviation = sample.means().get(sq) - meanOfMeans.get(sq);
                    varianceOfMeans.put(sq, varianceOfMeans.get(sq) + deviation * deviation);
                }
            }
            for (Square sq : model.legalMovesSpace()) {
                varianceOfMeans.put(sq, varianceOfMeans.get(sq) / (double) setSize);
            }

        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append("{#SampleSet# model=" + model + ", ");
            sb.append("size=" + setSize + ", ");
            sb.append("sampleSize=" + sampleSize+ ", ");
            sb.append("meanOfMeans=" + meanOfMeans() + ", ");
            sb.append("meanOfVariances=" + meanOfVariances() + ", ");
            sb.append("varianceOfMeans=" + varianceOfMeans() + "}");
            return sb.toString();
        }

        public Map<Square, Double> meanOfMeans() { return meanOfMeans; }
        public Map<Square, Double> meanOfVariances() { return meanOfVariances; }
        public Map<Square, Double> varianceOfMeans() { return varianceOfMeans; }
        public Set<Sample> samples() { return samples; }

    }

    private static class Sample {

        private List<Square> squares;
        private StatisticalModel model;

        /** Calculated fields. */
        private Map<Square, Integer> occurrences;
        private Map<Square, Double> means;
        private Map<Square, Double> variances;

        Sample(final List<Square> squares, final StatisticalModel model) {
            this.squares = squares;
            this.model = model;

            /** Calculates occurrences. */
            this.occurrences = new HashMap<Square, Integer>(model.enne());
            for (Square sq : model.legalMovesSpace()) {
                occurrences.put(sq, 0);
            }
            for (Square sq : squares) {
                occurrences.put(sq, occurrences.get(sq) + 1);
            }

            /** Calculates means. */
            this.means = new HashMap<Square, Double>(model.enne());
            for (Square sq0 : model.legalMovesSpace()) {
                this.means.put(sq0, (double) 0.);
                for (Square sq1 : this.squares) {
                    if (sq0.equals(sq1)) {
                        this.means.put(sq0, this.means.get(sq0) + (double) 1.);
                    }
                }
                this.means.put(sq0, this.means.get(sq0) / squares.size());
            }
            
            /** Calculates variances. */
            this.variances = new HashMap<Square, Double>(model.enne());
            for (Square sq0 : model.legalMovesSpace()) {
                this.variances.put(sq0, (double) 0.);
                for (Square sq1 : this.squares) {
                    double deviation;
                    if (sq0.equals(sq1)) {
                        deviation = 1. - this.means.get(sq0);
                    } else {
                        deviation = 0. - this.means.get(sq0);
                    }
                    this.variances.put(sq0, this.variances.get(sq0) + deviation * deviation);
                }
                this.variances.put(sq0, this.variances.get(sq0) / squares.size());
            }
            
        }

        StatisticalModel model() { return this.model; }
        List<Square> squares() { return this.squares; }
        Map<Square, Integer> occurrences() { return this.occurrences; }
        Map<Square, Double> means() { return this.means; }
        Map<Square, Double> variances() { return this.variances; }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append("{model=" + model + ", ");
            sb.append("size=" + squares.size() + ", ");
            sb.append("occurrences=" + occurrences + ", ");
            sb.append("means=" + means + ", ");
            sb.append("variances=" + variances + "}");
            return sb.toString();
        }

    }

    /** Tolerance factor to apply to the variance estimation. */
    static final double TOLERANCE_FACTOR = 2;

    @Test
    public final void testMove() {

        StatisticalModel[] models = {
            new StatisticalModel(GameSnapshotFixtures.INITIAL),
            new StatisticalModel(GameSnapshotFixtures.EARLY_GAME_BC3_10_MOVES),
            new StatisticalModel(GameSnapshotFixtures.G00_S01)
        };

        int[] sampleSizeArray = {10, 20, 40};
        int[] setSizeArray = {1, 100};

        for (StatisticalModel model : models) {
            for (int j = 0; j < sampleSizeArray.length; j++) {
                for (int i = 0; i < setSizeArray.length; i++) {

                    int sampleSize = sampleSizeArray[j];
                    int setSize = setSizeArray[i];
                    double expectedVarianceOfMeans;
                    if (setSize == 1) {
                        expectedVarianceOfMeans = 0.;
                    } else {
                        expectedVarianceOfMeans = model.variance() / (double) sampleSize;
                    }
                    SampleSet sampleSet = new SampleSet(sampleSize, setSize, model);

                    for (Square sq : model.legalMovesSpace()) {
                        double value = sampleSet.varianceOfMeans().get(sq);
                        assertTrue("sampleSet:" + sampleSet + "\n"
                                   + "sampleSet.varianceOfMeans().get(sq) is " + sampleSet.varianceOfMeans().get(sq) + "\n"
                                   + "expectedVarianceOfMeans is " + expectedVarianceOfMeans + "\n"
                                   + "TOLERANCE_FACTOR is " + TOLERANCE_FACTOR + "\n"
                                   + "It must be satisfied that: (sampleSet.varianceOfMeans().get(sq) >= 0 && "
                                   + "sampleSet.varianceOfMeans().get(sq) <= TOLERANCE_FACTOR * expectedVarianceOfMeans)",
                                   value >= 0 && value <= TOLERANCE_FACTOR * expectedVarianceOfMeans);
                    }
                }
            }
        }
    }

}