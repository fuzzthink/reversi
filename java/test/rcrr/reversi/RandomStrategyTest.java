/*
 *  RandomStrategyTest.java
 *
 *  Copyright (c) 2010, 2011 Roberto Corradini. All rights reserved.
 *
 *  This file is part of the reversi program
 *  http://github.com/rcrr/reversi
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation; either version 3, or (at your option) any
 *  later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
 *  or visit the site <http://www.gnu.org/licenses/>.
 */

package rcrr.reversi;

import org.joda.time.Duration;
import org.joda.time.Period;

import java.util.Map;
import java.util.HashMap;

import java.util.Set;
import java.util.HashSet;

import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;

import org.junit.*;
import static org.junit.Assert.*;

import static rcrr.reversi.Square.*;

/**
 * Test Suite for {@code RandomStrategy} class.
 * <p>
 * This test suite verifies that {@code RandomStrategy} returns
 * a statistical distribution of moves that is equally distributed
 * among the legal moves.
 * <p>
 * The <b>mean</b> of the chance to obtain a given move among <i>N</i> legal ones
 * is <i>1/N</i>.
 * <p>
 * The related <b>variance</b> is expressed by <i>(N-1)/N^2</i>.
 * <p>
 * For instance let's take a four legal move case: the mean is equal to <i>0.25</i>
 * while the variance is <i>0.1875</i>.
 * <p>
 * A sample population <i>p</i> is created running <i>k</i> times the random move strategy.
 * Let be:
 * <ul>
 *  <li><i>m</i> the mean value of the population (being <i>1/N</i>)</li>
 *  <li><i>v</i> the variance of the population (being <i>(N-1)/N^2</i>)</li>
 *  <li><i>k</i> the number of members of a sample population</li>
 *  <li><i>mk</i> the mean of the sample population composed by <i>k</i> members</li>
 *  <li><i>vk</i> the variance of the sample population composed by <i>k</i> members</li>
 * </ul>
 * <p>
 * Let now consider a population <i>q</i> of <i>j</i> members build taking the mean value
 * <i>mk</i> of <i>j</i> populations <i>p</i>, let be: 
 * <ul>
 *  <li><i>vmk</i> the variance of the population <i>q</i></li>
 * </ul>
 * <p>
 * The values of <i>v</i>, <i>vmk</i>, and <i>k</i> are binded by the following equation:
 * <ul>
 *  <li><i>vmk = v / k</i></li>
 * </ul>
 * <p>
 * The test verifies that, for a large enough <i>j</i> size, the calculated <i>vmk</i>
 * from the array of sample populations obtained calling the {@code RandomStrategy} code
 * is always less than two times the theoretical value:
 * <ul>
 *  <li><i>calculated(vmk) &lt 2 * (v / k)</i></li>
 * </ul>
 * <p>
 * The test, in other words, verifies that the
 * <a href="http://en.wikipedia.org/wiki/Central_limit_theorem" target="_blank">Central Limit Theorem</a>
 * is applicable to the sample populations generated by the {@code RandomStrategy} procedure,
 * confirming that the generation is random and normally distributed.
 */
public class RandomStrategyTest {

    /** Class constructor. */
    public RandomStrategyTest() { }

    static private class StatisticalModel {

        /** Strategy fixtures. */
        private Strategy strategy = new RandomStrategy();

        private final GameSnapshot snapshot;
        private final Set<Square> sampleSpace;
        private final int enne;
        private final double mean;
        private final double variance;

        StatisticalModel(final GameSnapshot snapshot) {
            this.snapshot = snapshot;
            this.sampleSpace = new HashSet<Square>(snapshot.board().legalMoves(snapshot.player()));
            this.enne = sampleSpace.size();
            this.mean = (double) 1. / (double) enne;
            this.variance = (double) (enne - 1) / (double) Math.pow((double) enne, 2.);
        }

        int enne() { return this.enne; }

        Set<Square> sampleSpace() { return this.sampleSpace; }

        Sample sample(final int kappa) {
            List<Square> squares = new ArrayList<Square>(kappa);
            for (int i=0; i<kappa; i++) {
                Square sq = strategy.move(snapshot).square();
                assertTrue(sampleSpace.contains(sq));
                squares.add(sq);
            }
            return new Sample(squares, this);
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append("Sample Space: " + sampleSpace + "\n");
            sb.append("N: " + enne + "\n");
            sb.append("m: " + mean + "\n");
            sb.append("v: " + variance + "\n");
            return sb.toString();
        }

    }

    private static class Sample {

        private List<Square> squares;
        private StatisticalModel model;

        /** Calculated fields. */
        private Map<Square, Integer> occurrences;

        Sample(final List<Square> squares, final StatisticalModel model) {
            this.squares = squares;
            this.model = model;

            this.occurrences = new HashMap<Square, Integer>(model.enne());
            for (Square sq : model.sampleSpace()) {
                occurrences.put(sq, 0);
            }
            for (Square sq : squares) {
                occurrences.put(sq, occurrences.get(sq) + 1);
            }
            
        }

        List<Square> squares() {
            return this.squares;
        }

        Map<Square, Integer> occurrences() {
            return this.occurrences;
        }

    }

    @Test
    public final void testReviewReminder() {
        fail("The Test Suite must be reviewed!");
    }

    private static final int TIMES = 2000;
    private static final double DEVIATION = 0.001;

    private static final List<Square> INITIAL_LEGAL_MOVES = Arrays.asList(E6, C4, F5, D3);
    private static final int N = INITIAL_LEGAL_MOVES.size();
    private static final double PROBABILITY = 1./N;

    /** Strategy fixtures. */
    private Strategy strategy = new RandomStrategy();
 
    private List<Square> randomSquareSample(int length) {
	List<Square> result = new ArrayList<Square>(length);
	for (int i=0; i<length; i++) {
	    Square sq = strategy.move(GameSnapshotFixtures.INITIAL).square();
	    assertTrue(INITIAL_LEGAL_MOVES.contains(sq));
	    result.add(sq);
	}
	return result;
    }

    private int count(Square sample, List<Square> distribution) {
	int count = 0;
	for (Square sq : distribution) {
	    if (sample == sq) count++;
	}
	return count;
    }

    private Set<Square> sampleSpace(final GameSnapshot snapshot) {
        return new HashSet<Square>(snapshot.board().legalMoves(snapshot.player()));
    }

    private List<Square> sample(final GameSnapshot snapshot, int size) {
	List<Square> sample = new ArrayList<Square>(size);
	for (int i=0; i<size; i++) {
	    Square sq = strategy.move(snapshot).square();
	    assertTrue(INITIAL_LEGAL_MOVES.contains(sq));
	    sample.add(sq);
	}
	return sample;
    }

    private Map<Square, Integer> occurrences(final Set<Square> sampleSpace, final List<Square> sample) {
        Map<Square, Integer> occurrences = new HashMap<Square, Integer>(sampleSpace.size());
        for (Square sq : sampleSpace) {
            occurrences.put(sq, 0);
        }
        for (Square sq : sample) {
            occurrences.put(sq, occurrences.get(sq) + 1);
        }
        return occurrences;
    }

    private Map<Square, Double> variances(final Set<Square> sampleSpace, final List<Square> sample) {
        Map<Square, Double> result = new HashMap<Square, Double>();
        int n = sampleSpace.size();
        int k = sample.size();
        double p1 = (double) 1 / n;
        double p2 = (double) (n - 1) / n;
        for (Square key : sampleSpace) {
            double variance = 0.;
            for (Square sq : sample) {
                if (sq.equals(key)) {
                    variance += (1-p1)*(1-p1);
                } else {
                    variance += (0-p1)*(0-p1);
                }
            }
            variance = variance / k;
            result.put(key, variance);
        }
        return result;
    }

    private Map<Square, Double> frequencies(final Map<Square, Integer> occurrences) {
        double sampleSpaceSize = occurrences.size();
        Map<Square, Double> frequencies = new HashMap<Square, Double>(occurrences.size());
        double sampleSize = 0.;
        for (Square sq : occurrences.keySet()) {
            sampleSize += (double) occurrences.get(sq);
        }
        for (Square sq : occurrences.keySet()) {
            frequencies.put(sq, (double) occurrences.get(sq) / sampleSize);
        }
        return frequencies;
    }

    private List<Map<Square, Double>> frequenciesSample(final GameSnapshot snapshot, final int kappa, final int size) {
        List<Map<Square, Double>> frequenciesSample = new ArrayList<Map<Square, Double>>();

        Set<Square> sampleSpace = sampleSpace(snapshot);
        for (int i = 0; i < kappa; i++) {
            List<Square> sample = sample(snapshot, size);
            Map<Square, Integer> occurrences = occurrences(sampleSpace, sample);
            Map<Square, Double> frequencies = frequencies(occurrences);
            //Map<Square, Double> variances = variances(sampleSpace, sample);
            frequenciesSample.add(frequencies);
        }
        return frequenciesSample;
    }

    @Test
    public final void testUnderConstruction() {

        System.out.println("Under Construction START");

        GameSnapshot env = GameSnapshotFixtures.INITIAL;
        Set<Square> sampleSpace = sampleSpace(env);
        System.out.println("sampleSpace = " + sampleSpace);

        int sampleSpaceSize = sampleSpace.size();
        System.out.println("sampleSpaceSize = " + sampleSpaceSize);

        double mean = (double) 1 / (double) sampleSpaceSize;

        int sampleSize = 1000 * sampleSpaceSize;
        System.out.println("sampleSize = " + sampleSize);

        List<Square> sample = sample(env, sampleSize);
        //System.out.println("sample = " + sample);

        Map<Square, Integer> occurrences = occurrences(sampleSpace, sample);
        System.out.println("occurrences = " + occurrences);

        Map<Square, Double> frequencies = frequencies(occurrences);
        System.out.println("frequencies = " + frequencies);

        Map<Square, Double> variances = variances(sampleSpace, sample);
        System.out.println("variances = " + variances);

        int kappa = 10000;
        int enne = 10;
        List<Map<Square, Double>> frequenciesSample = frequenciesSample(env, kappa, enne);
        //System.out.println("frequenciesSample = " + frequenciesSample);

        Map<Square, Double> meanVariances = new HashMap<Square, Double>();
        for (Square key : sampleSpace) {
            meanVariances.put(key, 0.);
        }
        for (Map<Square, Double> f : frequenciesSample) {
            for (Square key : sampleSpace) {
                meanVariances.put(key, meanVariances.get(key) + (f.get(key) - mean) * (f.get(key) - mean));
            }
        }
        for(Square key : meanVariances.keySet()) {
            meanVariances.put(key, meanVariances.get(key) / (double) kappa);            
        }
        System.out.println("meanVariances = " + meanVariances);


        StatisticalModel model = new StatisticalModel(GameSnapshotFixtures.INITIAL);
        System.out.println("model = " + model);

        System.out.println("Under Construction STOP");


    }

    /**
     * Binomial Coefficient: see http://en.wikipedia.org/wiki/Binomial_distribution
     */
    @Test
    public void testMove() {
	List<Square> distribution = randomSquareSample(TIMES);
	Map<Square, Double> result = new HashMap<Square, Double>(N);
	for (Square sq : INITIAL_LEGAL_MOVES) {
	    result.put(sq, Math.pow(count(sq, distribution)/Float.valueOf(TIMES)-PROBABILITY, 2));
	}
	for (Square sq : INITIAL_LEGAL_MOVES) {
	    assertTrue(result.get(sq) < DEVIATION);
	}
    }
    

}