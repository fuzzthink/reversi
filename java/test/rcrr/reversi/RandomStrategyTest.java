/*
 *  RandomStrategyTest.java
 *
 *  Copyright (c) 2010, 2011 Roberto Corradini. All rights reserved.
 *
 *  This file is part of the reversi program
 *  http://github.com/rcrr/reversi
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation; either version 3, or (at your option) any
 *  later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
 *  or visit the site <http://www.gnu.org/licenses/>.
 */

package rcrr.reversi;

import java.util.Map;
import java.util.HashMap;

import java.util.Set;
import java.util.HashSet;

import java.util.List;
import java.util.ArrayList;

import org.junit.Test;
import static org.junit.Assert.assertTrue;

/**
 * Test Suite for {@code RandomStrategy} class.
 * <p>
 * This test suite verifies that {@code RandomStrategy} returns
 * a statistical distribution of moves that is equally distributed
 * among the legal moves.
 * <p>
 * The <b>mean</b> of the chance to obtain a given move among <i>N</i> legal ones
 * is <i>1/N</i>.
 * <p>
 * The related <b>variance</b> is expressed by <i>(N-1)/N^2</i>.
 * <p>
 * For instance let's take a four legal move case: the mean is equal to <i>0.25</i>
 * while the variance is <i>0.1875</i>.
 * <p>
 * A sample population <i>p</i> is created running <i>k</i> times the random move strategy.
 * Let be:
 * <ul>
 *  <li><i>m</i> the mean value of the population (being <i>1/N</i>)</li>
 *  <li><i>v</i> the variance of the population (being <i>(N-1)/N^2</i>)</li>
 *  <li><i>k</i> the number of members of a sample population</li>
 *  <li><i>mk</i> the mean of the sample population composed by <i>k</i> members</li>
 *  <li><i>vk</i> the variance of the sample population composed by <i>k</i> members</li>
 * </ul>
 * <p>
 * Let now consider a population <i>q</i> of <i>j</i> members build taking the mean value
 * <i>mk</i> of <i>j</i> populations <i>p</i>, let be:
 * <ul>
 *  <li><i>vmk</i> the variance of the population <i>q</i></li>
 * </ul>
 * <p>
 * The values of <i>v</i>, <i>vmk</i>, and <i>k</i> are binded by the following equation:
 * <ul>
 *  <li><i>vmk = v / k</i></li>
 * </ul>
 * <p>
 * The test verifies that, for a large enough <i>j</i> size, the calculated <i>vmk</i>
 * from the array of sample populations obtained calling the {@code RandomStrategy} code
 * is always less than two times the theoretical value:
 * <ul>
 *  <li><i>calculated(vmk) &lt 2 * (v / k)</i></li>
 * </ul>
 * <p>
 * The test, in other words, verifies that the
 * <a href="http://en.wikipedia.org/wiki/Central_limit_theorem" target="_blank">Central Limit Theorem</a>
 * is applicable to the sample populations generated by the {@code RandomStrategy} procedure,
 * confirming that the generation is random and normally distributed.
 */
public class RandomStrategyTest {

    /** Class constructor. */
    public RandomStrategyTest() { }

    /**
     * A statistical model is a wrapper for a game snapshot.
     * <p>
     * It is used to compute the main statistical properties for the given snapshot.
     */
    private static class StatisticalModel {

        /** The random strategy generating the sample populations. */
        private Strategy strategy = new RandomStrategy();

        /** The game snapshot representing the statistical environment. */
        private final GameSnapshot snapshot;

        /** The set of all possible values. */
        private final Set<Square> legalMovesSpace;

        /** The numorosity of the legal moves space. */
        private final int enne;

        /** The theoretical probability to receive a given value from a random selection. */
        private final double mean;

        /** The theoretical statistical variance of a sample population of random selection. */
        private final double variance;

        /**
         * Class constructor.
         *
         * @param snapshot the game snapshot used to define the statistical model
         */
        StatisticalModel(final GameSnapshot snapshot) {
            this.snapshot = snapshot;
            this.legalMovesSpace = new HashSet<Square>(snapshot.board().legalMoves(snapshot.player()));
            this.enne = legalMovesSpace.size();
            this.mean = (double) 1. / (double) enne;
            this.variance = (double) (enne - 1) / (double) Math.pow((double) enne, 2.);
        }

        /**
         * Returns the enne field.
         *
         * @return the enne field
         */
        int enne() {
            return this.enne;
        }

        /**
         * Returns the mean field.
         *
         * @return the mean field
         */
        double mean() {
            return this.mean;
        }

        /**
         * Returns the variance field.
         *
         * @return the variance field
         */
        double variance() {
            return this.variance;
        }

        /**
         * Returns the snapshot field.
         *
         * @return the snapshot field
         */
        GameSnapshot snapshot() {
            return this.snapshot;
        }

        /**
         * Returns the set of square that are available as legal moves.
         *
         * @return the available legal moves set
         */
        Set<Square> legalMovesSpace() {
            return this.legalMovesSpace;
        }

        /**
         * Returns a new sample related to the model.
         *
         * @param sampleSize the number of moves componing the sample
         * @return           a new sample
         */
        Sample sample(final int sampleSize) {
            List<Square> squares = new ArrayList<Square>(sampleSize);
            for (int i = 0; i < sampleSize; i++) {
                Square sq = strategy.move(snapshot).square();
                assertTrue(legalMovesSpace.contains(sq));
                squares.add(sq);
            }
            return new Sample(squares, this);
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append("{legalMovesSpace=" + legalMovesSpace + ", ");
            sb.append("enne=" + enne + ", ");
            sb.append("mean=" + mean + ", ");
            sb.append("variance=" + variance + "}");
            return sb.toString();
        }

    }

    /**
     * A semple set is a collection of sample associated with a model.
     */
    private static class SampleSet {

        /** The model field. */
        private final StatisticalModel model;

        /** The samples field. */
        private final Set<Sample> samples;

        /** The sampleSize field. */
        private final int sampleSize;

        /** The setSize field. */
        private final int setSize;

        /** The meansOfMeans field. */
        private final Map<Square, Double> meansOfMeans;

        /** The meansOfVariances field. */
        private final Map<Square, Double> meansOfVariances;

        /** The variancesOfMeans field. */
        private final Map<Square, Double> variancesOfMeans;

        /**
         * Class constructor.
         *
         * @param sampleSize the number of squares per sample
         * @param setSize    the number of samples
         * @param model      the reference statistical model
         */
        SampleSet(final int sampleSize, final int setSize, final StatisticalModel model) {
            this.model = model;
            this.sampleSize = sampleSize;
            this.setSize = setSize;
            this.samples = new HashSet<Sample>(setSize);
            for (int k = 0; k < setSize; k++) {
                samples.add(model.sample(sampleSize));
            }

            /** Calculates the means of the means. */
            this.meansOfMeans = new HashMap<Square, Double>(model.enne());
            for (Square sq : model.legalMovesSpace()) {
                meansOfMeans.put(sq, (double) 0.);
            }
            for (Sample sample : this.samples) {
                for (Square sq : model.legalMovesSpace()) {
                    meansOfMeans.put(sq, meansOfMeans.get(sq) + sample.means().get(sq));
                }
            }
            for (Square sq : model.legalMovesSpace()) {
                meansOfMeans.put(sq, meansOfMeans.get(sq) / (double) setSize);
            }

            /** Calculates the means of the variances. */
            this.meansOfVariances = new HashMap<Square, Double>(model.enne());
            for (Square sq : model.legalMovesSpace()) {
                meansOfVariances.put(sq, (double) 0.);
            }
            for (Sample sample : this.samples) {
                for (Square sq : model.legalMovesSpace()) {
                    meansOfVariances.put(sq, meansOfVariances.get(sq) + sample.variances().get(sq));
                }
            }
            for (Square sq : model.legalMovesSpace()) {
                meansOfVariances.put(sq, meansOfVariances.get(sq) / (double) setSize);
            }

            /** Calculates the variances of the means. */
            this.variancesOfMeans = new HashMap<Square, Double>(model.enne());
            for (Square sq : model.legalMovesSpace()) {
                variancesOfMeans.put(sq, (double) 0.);
            }
            for (Sample sample : this.samples) {
                for (Square sq : model.legalMovesSpace()) {
                    double deviation = sample.means().get(sq) - meansOfMeans.get(sq);
                    variancesOfMeans.put(sq, variancesOfMeans.get(sq) + deviation * deviation);
                }
            }
            for (Square sq : model.legalMovesSpace()) {
                variancesOfMeans.put(sq, variancesOfMeans.get(sq) / (double) setSize);
            }

        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append("{#SampleSet# model=" + model + ", ");
            sb.append("size=" + setSize + ", ");
            sb.append("sampleSize=" + sampleSize + ", ");
            sb.append("meansOfMeans=" + meansOfMeans() + ", ");
            sb.append("meansOfVariances=" + meansOfVariances() + ", ");
            sb.append("variancesOfMeans=" + variancesOfMeans() + "}");
            return sb.toString();
        }

        /**
         * Returns the mean map of the means obtained from the samples contained into the sample set.
         *
         * @return the meansOfMeans field
         */
        public Map<Square, Double> meansOfMeans() {
            return meansOfMeans;
        }

        /**
         * Returns the mean map of the variances obtained from the samples contained into the sample set.
         *
         * @return the meansOfVariances field
         */
        public Map<Square, Double> meansOfVariances() {
            return meansOfVariances;
        }

        /**
         * Returns the variance map of the meanss obtained from the samples contained into the sample set.
         *
         * @return the variancesOfMeans field
         */
        public Map<Square, Double> variancesOfMeans() {
            return variancesOfMeans;
        }

        /**
         * Returns the samples field.
         *
         * @return the samples field
         */
        public Set<Sample> samples() {
            return samples;
        }

    }

    /**
     * A sample is a wrapper for a list of moves (squares) associated with a statistical model.
     */
    private static class Sample {

        /** the squares field. */
        private List<Square> squares;

        /** The model field. */
        private StatisticalModel model;

        /** Calculated field occurrences. */
        private Map<Square, Integer> occurrences;

        /** Calculated field means. */
        private Map<Square, Double> means;

        /** Calculated field variances. */
        private Map<Square, Double> variances;

        /**
         * Class constructor.
         *
         * @param squares the list of moves (squares)
         * @param model   the reference statistical model
         */
        Sample(final List<Square> squares, final StatisticalModel model) {
            this.squares = squares;
            this.model = model;

            /** Calculates occurrences. */
            this.occurrences = new HashMap<Square, Integer>(model.enne());
            for (Square sq : model.legalMovesSpace()) {
                occurrences.put(sq, 0);
            }
            for (Square sq : squares) {
                occurrences.put(sq, occurrences.get(sq) + 1);
            }

            /** Calculates means. */
            this.means = new HashMap<Square, Double>(model.enne());
            for (Square sq0 : model.legalMovesSpace()) {
                this.means.put(sq0, (double) 0.);
                for (Square sq1 : this.squares) {
                    if (sq0.equals(sq1)) {
                        this.means.put(sq0, this.means.get(sq0) + (double) 1.);
                    }
                }
                this.means.put(sq0, this.means.get(sq0) / squares.size());
            }

            /** Calculates variances. */
            this.variances = new HashMap<Square, Double>(model.enne());
            for (Square sq0 : model.legalMovesSpace()) {
                this.variances.put(sq0, (double) 0.);
                for (Square sq1 : this.squares) {
                    double deviation;
                    if (sq0.equals(sq1)) {
                        deviation = 1. - this.means.get(sq0);
                    } else {
                        deviation = 0. - this.means.get(sq0);
                    }
                    this.variances.put(sq0, this.variances.get(sq0) + deviation * deviation);
                }
                this.variances.put(sq0, this.variances.get(sq0) / squares.size());
            }
        }

        /**
         * Returns the model field.
         *
         * @return the model field.
         */
        StatisticalModel model() {
            return this.model;
        }

        /**
         * Returns the squares field.
         *
         * @return the squares field.
         */
        List<Square> squares() {
            return this.squares;
        }

        /**
         * Returns the occurrences field.
         *
         * @return the occurrences field.
         */
        Map<Square, Integer> occurrences() {
            return this.occurrences;
        }

        /**
         * Returns the means field.
         *
         * @return the means field.
         */
        Map<Square, Double> means() {
            return this.means;
        }

        /**
         * Returns the variances field.
         *
         * @return the variances field.
         */
        Map<Square, Double> variances() {
            return this.variances;
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append("{model=" + model + ", ");
            sb.append("size=" + squares.size() + ", ");
            sb.append("occurrences=" + occurrences + ", ");
            sb.append("means=" + means + ", ");
            sb.append("variances=" + variances + "}");
            return sb.toString();
        }

    }

    /** Tolerance factor to apply to the variance estimation. */
    static final double TOLERANCE_FACTOR = 2;

    /**
     * Tests the {@code move(GameSnapshot)} method.
     * <p>
     * The test verify on different game snapshot that the move provided
     * by the random strategy satisfies the statistical properties required by
     * the "<i>Central Limit Theorem</i>".
     *
     * @see GameSnapshotFixtures#INITIAL
     * @see GameSnapshotFixtures#EARLY_GAME_BC3_10_MOVES
     * @see GameSnapshotFixtures#G00_S01
     */
    @Test
    public final void testMove() {

        StatisticalModel[] models = {
            new StatisticalModel(GameSnapshotFixtures.INITIAL),
            new StatisticalModel(GameSnapshotFixtures.EARLY_GAME_BC3_10_MOVES),
            new StatisticalModel(GameSnapshotFixtures.G00_S01)
        };

        int[] sampleSizeArray = {10, 20, 40};
        int[] setSizeArray = {1, 100};

        for (StatisticalModel model : models) {
            for (int j = 0; j < sampleSizeArray.length; j++) {
                for (int i = 0; i < setSizeArray.length; i++) {

                    int sampleSize = sampleSizeArray[j];
                    int setSize = setSizeArray[i];
                    double expectedVarianceOfMeans;
                    if (setSize == 1) {
                        expectedVarianceOfMeans = 0.;
                    } else {
                        expectedVarianceOfMeans = model.variance() / (double) sampleSize;
                    }
                    SampleSet sampleSet = new SampleSet(sampleSize, setSize, model);

                    for (Square sq : model.legalMovesSpace()) {
                        double value = sampleSet.variancesOfMeans().get(sq);
                        assertTrue("sampleSet:" + sampleSet + "\n"
                                   + "sampleSet.variancesOfMeans().get(sq) is "
                                   + sampleSet.variancesOfMeans().get(sq) + "\n"
                                   + "expectedVarianceOfMeans is " + expectedVarianceOfMeans + "\n"
                                   + "TOLERANCE_FACTOR is " + TOLERANCE_FACTOR + "\n"
                                   + "It must be satisfied that: (sampleSet.variancesOfMeans().get(sq) >= 0 && "
                                   + "sampleSet.variancesOfMeans().get(sq) <="
                                   + " TOLERANCE_FACTOR * expectedVarianceOfMeans)",
                                   value >= 0 && value <= TOLERANCE_FACTOR * expectedVarianceOfMeans);
                    }
                }
            }
        }
    }

}
